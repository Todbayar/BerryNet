#define microsecToSec 1000000
#define timeToSleep 600 //10min

RTC_DATA_ATTR int bootCount = 0;

hw_timer_t * timerWater = NULL;
portMUX_TYPE timerWaterMux = portMUX_INITIALIZER_UNLOCKED;

void IRAM_ATTR waterOnTime(){
  portENTER_CRITICAL_ISR(&timerWaterMux);
  if(vSoilMoist < 40){
    digitalWrite(pinRelayWaterMotor, LOW);  //pump
  }
  else {
    digitalWrite(pinRelayWaterMotor, HIGH);  //off
  }
  portEXIT_CRITICAL_ISR(&timerWaterMux);
}

void print_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
  switch(wakeup_reason){
    case ESP_SLEEP_WAKEUP_EXT0: vStat = "Wakeup RTC_IO"; break;
    case ESP_SLEEP_WAKEUP_EXT1: vStat = "Wakeup RTC_CNTL"; break;
    case ESP_SLEEP_WAKEUP_TIMER: vStat = "Wakeup Timer"; break;
    case ESP_SLEEP_WAKEUP_ULP: vStat = "Wakeup ULP"; break;
    default: vStat = "Wakeup " + String(wakeup_reason); break;
  }
}

setup(){
    print_wakeup_reason();
    esp_sleep_enable_timer_wakeup(timeToSleep * microsecToSec);

    // timerWater = timerBegin(0, 80, true);
    // timerAttachInterrupt(timerWater, &waterOnTime, true);
    // timerAlarmWrite(timerWater, 30000000L, true);
    // timerAlarmEnable(timerWater);

    // delay(1000);
    // Serial.flush();
    // vStat = "Sleep";
    // delay(4000);
    // esp_deep_sleep_start();
}